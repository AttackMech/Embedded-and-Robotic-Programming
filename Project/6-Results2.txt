Discussion and Analysis

So the robot didn't turn out to be 100% perfect.  This should be expected of course, but I was still a little disappointed in the results.  Here are some of the issues I encountered:

1. Environment

My current home is a loft.  As such, I don't have a proper bedroom to test the device.  I took the robot into the hallway for filming, providing obstacles with the walls of the room and some cardboard boxes.  The robot behaved mostly as expected, avoiding obstacles, and reacting to movement.  I tested it in my living room as well, and it was able to avoid walls and furniture there as well, but it did get stuck under my couch a few times because it was the perfect height to be undetectable to the sensors, but still managed to catch on the wires that protrude above the device.

Another issue is that of carpeting.  I live in Korea, where most floors are not covered by carpet.  This is because the heating system used here is through heated pipes or electric mats under the floor (called 'ondol' http://www.korea-heating.eu/_1ondol_eng.php heating).  To try and simulate carpeting somewhat, I did have to robot move small amounts on my bed and couch.  However, the limited space restricted full testing.  The robot was able to move in this space, so I would assume that it could move easily on low-pile carpeting without issue.

I also ran tests with piles of clothes on the floor, trying to simulate a messy bedroom environment.  The robot was intermittent in its ability to detect this.  Of course, it could only detect items that were high enough to be in sensor range.  This caused the robot to drag some of the smaller items around with it as it moved, also causing it to stop in some cases because it does not employ very powerful motors (more on that below).  Clothing that did meet the height requirement were still somewhat problematic.  The robot would run into them at times and get stuck, although most times it was able to back away and get itself out of the situation.  I am assuming that it could not detect the clothes because the irregular pattern of the clothing scattered the ultrasonic waves, or the material was able to absorb them somehow.

2. Sensors

I also had other issues with the ultrasonic sensors being unreliable in general.  The arrangement that I have, has one forward facing sensor, with 2 more facing left and right at almost 90 degree angles.  This arrangement worked quite well for walls and large objects.  However, thin objects, such as chair legs, did pose some difficulty.  The robot would run into these fairly often.  Obviously, one way to alleviate the problem would be to have more sensors to provide a fuller coverage area.  However, the bigger issue that I discovered through testing is that my sensors are just not very good.  Or at the very least, are not very good for their intended purpose.

I purchased very cheap sensors.  They only cost about $3 a piece.  When I first got them, I tested them to make sure that they were working properly and calibrated.  In static tests, they detected distance quite well and provided quite accurate readings.  The next phase of testing was mounting them to the chassis and using them for their intended purpose, but not in coordination with the motors.  This proved to work well also.  Overall, in both static tests, I was quite happy with the performance.  The results were accurate and there was very little, if any, fluctuation in the readings.

The third phase of testing had the sensor inputs controlling the motor outputs.  I had the robot propped up so that he wheels could turn without actually moving the robot.  When the sensors read an object within a danger zone of 15cm, it would take action by turning or reversing direction, at all other times it would move forward.  I noticed that this caused a small but significant change in the behaviour of the sensors.  Sensor readings started to become inaccurate.  Usually this was on the order of a few centimeters, but in some cases spiked over 10cm.  There was a more significant impact on the fluctuation of the readings.  The readings seemed to fluctuate around 75% of the time!  Yet again, these fluctuations were usually on the order of only a few centimeters.  However, noticing this, I took steps to correct these errors.

Originally, I used only direct readings from the sensors.  Each loop of the program ran through the each of the sensors.  I had allowed time between each reading to account for any interference from reading one after the other.  To account for the fluctuations in readings, I used an array to track the history of previous sensor recordings.  If results of successive readings were both within the danger zone, I assumed the readings to be valid enough to have the robot take action.  To handle fluctuation, I compared current readings within a certain threshold of previous readings to help eliminate aberrations.

With this solution in place, I moved on the final testing phase.  This is where the robot has free movement to act.  I noticed a larger change in both the accuracy and fluctuation of the sensor readings.  I have no exact data, but the results ended up being fairly unreliable.  I kept a similar solution, but tweaked the thresholds that I was willing to accept through trial-and-error.  This ended up working for most cases.  Nevertheless, the robot would still detect movement when there was none.  This I deemed acceptable because the robot is moving most of the time anyway, and I'd rather have it be jumpy than not sensitive enough.  The results were less effective for object detection while steering.  I found that the robot occasionally would run into walls because they would be undetected.  I then instituted a 'stuck' scenario that would compare results of previous readings.  If the results were that robot had similar readings after several rounds, it would back out of it's current position and turn around.  This worked well because the robot was not moving, providing more reliable results to test if it was stuck.

3. Motors

When I purchased the parts for this project.  I found a preassembled chassis with motors already in place.  These motors were smaller than those included with the SIK.  However, the mounts for the motors only accommodated the smaller size, so switching them out would have been worth the effort.  As noted in my previous video experimenting with the SIK motors, there was a torque issue with the motors at low speeds.  I was not worried about these issues because the robot would be basically moving at full speed at all times.  However, as noted in my project video, I was dissatisfied with the final speed of the robot.  My original intention for the robot was for it to be high speed, being able to run away from a person.  Ideally this would have been faster than walking speed.  Unfortunately, this did not end up being the case.  The robot was extremely slow and could easily be caught by anyone.  There was no real fix for this other than installing new motors, which would have been difficult, costly, and time-consuming.

Still, this was not the only motor issue I encountered.  As the project progressed, a problem began occurring as the robot would not move in a straight line.  In the initial testing phases this was not a problem.  To get the robot to move forward, I simply set both motors to run at maximum capacity.  Each motor running at the same rate produced forward motion in a straight line.  When the project progressed further, the movement became less reliable.  The left motor began to perform much worse.  This caused the robot to turn constantly, instead of moving straight.  This behaviour is noticeable in some of my video footage.  I tried to correct for this as best I could by having the left motor operate at full capacity while the right was reduced.  It took several rounds of trial and error to find the correct amounts.  However, this did not completely solve the problem.  As the battery power became weaker, the problem would get worse in relation (more on power issues below).

I have several theories as to the culprit causing this problem.  First of all, there could have been a load balance issue with the robot, but the turning was significant enough and the components light enough that I believe it could not have been the only issue.  Secondly, I may have damaged one of the motors or wheels.  I have transported the robot around quite a lot and this could have happened, even though I tried to be very careful.  Finally, there could have been debris caught in the axle mechanism.  Since the robot runs on the floor, it can easily pick up debris.  Hair could have been wrapped up in the mechanism, thus affecting performance.  I looked as close as I could and didn't see anything.  There could also be issues that I am unaware of such as defective parts and more.

4. Alarm

With the original clock module for this project, when the alarm goes off, a time check is used to cause the buzzer to beep in short pulses instead of producing a long tone.  This happens every cycle through the main loop while the alarm is active.  On it's own this is fine.  With my motor control added to the mix, it caused some issues.  To control the motors, I have the program pause for a certain amount of time to allow the steering action to occur.  For example, turning left involves having the left motor move at low speeds, while the right moves much faster.  I pause the program for a period of time corresponding to how much I want the robot to turn.  Yet this causes a problem with the alarm because the main loop executes very quickly, while steering actions take orders of magnitude longer.  This caused the alarm sound to be erratic instead of regular.  One reason I chose not to change this is because I found this erratic behaviour to be even more annoying!  This serves the alarms intended purpose of trying to get someone out of bed to shut it off.

Nevertheless, this implementation would not allow for a custom song or other regular tune to be played as an alarm, which is a feature of many alarm clocks.  The best solution for this would be to use threading, having the alarm and steering run on separate threads.  I looked into this, but the Arduino hardware does not support threading.  The software solutions I found made use of interrupts, and may have sufficed, but only with a significant amount of programming effort.  Any tune would have to be cropped into intervals to play, and changes to the alarm playing and motor control functions would be needed.  Since the current action sufficed, I chose not to venture down this path.

As small related issue, this lack of threading also had a impact on button responsiveness.  The button states were also read once per cycle.  This makes turning the alarm off difficult if a very quick button press is used.  I almost didn't notice this issue, because in most cases the time to push in a button was not often less than the delay induced by the motor control mechanism.

5. Power

Another issue I had was with power, in two different ways.  The first issue was that of power consumption.  With the RedBoard, motors, sensors, LCD and more all running, there can be quite a drain on batteries.  Because the robot must move independently around a home environment, a cord attached the device is not an option.  I used a set of 4 AA batteries to run the robot.  I noticed that batteries ran out very quickly.  This is partly because I used very cheap batteries, but also because of the amount power used was significant.  The second issue is the overall amount of power available.  When the alarm goes off, everything is running at once.  I noted in my first project video that the LCD would dim slightly when the buzzer was functioning.  This problem was exacerbated in the complete model when motors and sensors were added to the mix.  The display was not unreadable, but there was a appreciable impact.  This was especially noticeable as the batteries began to be quickly drained.

The solution to this is obviously using a larger battery capacity with better output, but I did not look into it.  I am not sure how much current and voltage the RedBoard supports, but the output is limited to 5V.  Also, most household devices run on AA batteries.  I worked within the limitations of the hardware, and just bought a lot of cheap batteries.
